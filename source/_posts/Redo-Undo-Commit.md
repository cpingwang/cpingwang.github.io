---
title: Redo-Undo-Commit
date: 2016-11-01 17:59:04
tags: DB
---

Redo
---
    Redo log files are the transaction logs for the database.
	Oracle maintains two types of redo log files: online and archived.
	They are used for recovery purposes.
Redo log就是DB的交易記錄，最主要是的用途是復原資料。

{% asset_img redolog.png %}

---
    Every Oracle database has at least two online redo log groups with at least a single member(redo log file) in each group.
	These online redo log groups are used in a circular fashion.
每個Oracle DB 至少會有2個online的redo log組成redo log groups(每個redo log至少會有一個member)，並以循環的方使用。

{% asset_img RedoLogMembers.png %}

---

Undo
---
    Undo information is generated by the database as you make modifications to data to put it back the way it was before the modifications,
	in the event the transaction or statement you are executing fails for any reason or if you request it with a ROLLBACK statement.
Undo是將資料回復到修改之前的狀態，通常因為某些原因或交易失敗而執行ROLLBACK。

---
    The database is logically restored to the way it was, any changes are logically undone,
	the database blocks themselves, may well be different after a rollback.
Rollback是邏輯上將資料回復到原本的狀態，在Rollback以後實際資料存放的區塊與原本完全不同。
	
---

Commit
---
    A COMMIT is generally a very fast operation, regardless of the transaction size.
COMMIT通常是一個很快的動作，與交易的大小無關。

---
    If a COMMIT of one row takes X units of time, and the COMMIT of 1,000 rows takes the same X units of time.
COMMIT一筆資料列跟commit一千筆資料列同樣都是花費X的單位時間。

---
    By committing only when you have to(when the logical unit of work is complete),
    you will not only increase performance,	but also reduce contention for shared resources
	(log files, various internal latches...).
有需要時才COMMIT(商業邏輯完成時)，如此非但可以增加效能，更可以減少共用資源的使用。

---
    It is best to size our transactions based on business need,
	not based on misguided attempts to lessen resource usage on the database.
依據商業邏輯的需求去控制交易的大小，而非基於減少DB資源的誤導嘗試。

---	
    There are two contributing factors to the expense of the COMMIT:
    • We’ve obviously increased the round-trips to and from the database. 
      If we commit every record, we are generating that much more traffic back and forth.
    • Every time we commit, we must wait for our redo to be written to disk. This will result in a “wait.” 
      In this case, the wait is named “log file sync”.
COMMIT對系統的兩個主要花費如下:
• 數據的往返，多次的Commit會增加更多的流量來回
• 每當我們COMMIT就必須等待RedoLog寫入Disk。這個等待叫作“log file sync.”

---
    When we committed after every INSERT, we waited almost every time—and if you wait a little bit of time but you wait often, then it all adds up.
每次COMMIT一筆INSERT都要等待一點時間，所以如果我們Commit很多次，結果會是這些時間的加總。

---
    Before we even go to COMMIT in the database, we’ve already done the really hard work. 
    We’ve already modified the data in the database, so we’ve already done 99.9 percent of the work. 
    Operations such as the following have already taken place:
    • Undo blocks have been generated in the SGA.
    • Modified data blocks have been generated in the SGA.
    • Buffered redo for the preceding two items has been generated in the SGA.
    • Depending on the size of the preceding three items, and the amount of time spent,some combination of the previous data may be flushed onto disk already.
    • All locks have been acquired.
在執行COMMIT前，其實DB已經把真正困難的工作都完成了，幾乎99.9%都已經完成...
• Undo區塊已在SGA產生好。
• 修改後的資料區塊已在SGA產生好。
• 前兩項的Buffered redo已在SGA產生好。
• 依據資料量的大小及時間而定，前三項的資料有部分也已經寫入Disk。
• 取得所有需要的locks。

---	
    When we COMMIT, all that is left to happen is the following:
    • An SCN is generated for our transaction.
      (SCN is a simple timing mechanism Oracle uses to guarantee the ordering of transactions and to enable recovery from failure.
       It is also used to guarantee read-consistency and checkpointing in the database.
       Think of the SCN as a ticker; every time someone COMMITs, the SCN is incremented by one.)
    • LGWR writes all of our remaining buffered redo log entries to disk and records the SCN in the online redo log files as well.
      This step is actually the COMMIT. If this step occurs, we have committed.
      Our transaction entry is “removed” from V$TRANSACTION—this shows that we have committed.
    • All locks recorded in V$LOCK held by our session are released,
      and everyone who was enqueued waiting on locks we held will be woken up and allowed to proceed with their work.
    • Some of the blocks our transaction modified will be visited and “cleaned out” in a fast mode if they are still in the buffer cache.
      (Block cleanout refers to the lock-related information we store in the database block header.
       Basically, we are cleaning out our transaction information on the block, so the next person who visits the block won’t have to.)
在COMMIT之後剩餘所需執行的工作如下:
• 產生交易的SCN(System Change Number)。
• LGWR將所有剩餘的Buffered redo全部寫入Disk，並且在online redo log上記錄SCN。
• 釋放本交易相關的locks，所有正在等待我們的lock的工作都會被喚醒並執行。
• 原本交易所使用的區塊會被快速釋放或重新被其他的交易使用。

---
    以上資料參考自: Thomas.Kyte - Expert Oracle Database Architecture
